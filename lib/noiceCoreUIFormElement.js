import { noiceCoreUIElement } from './noiceCoreUI.js';
import { noiceObjectCore, noiceException } from './noiceCore.js';

/*
    noiceCoreUIFormElement

    this defines noiceCoreUIElement descendant classes
    for form elements. These are the two I've got going

        * dropdown
        * input

    these are all the possible HTML form elements though
    and we might wanna look into these:
        <button>, <datalist>, <fieldset>, <input>,<keygen>, <label>,
        <legend>, <meter>, <optgroup>, <option>, <output>, <progress>,
        <select>, <textarea>

    a child of this class has this form in html:

    <div [auto-generated by noiceCoireUIElement]>
        <label for="${this.formElementGUID}" class="${this.labelClass}">${this.label}</label>
        <input id="${this.formElementGUID}" name="${this.name}" ${(this.enable)?'enabled':'disabled'}></input>
    </div>

    the layout mode of the containing div controls how the label is arranged in relation to the input element
    (or select or whatever the target form element is). This is controlled by the labelLocation attribute (see
    constructor notes).

    this.formElementLabel gives a reference to the label element
    this.formElement gives a reference to the target form element (select, input, etc)

    this.value gets and sets the value of this.formDOMElement

    this.valueChangeCallback() - this is an external callback invoked with the old and new values
    the callback can throw to abort setting the value. If the callback wants to handle self-assignment
    (that is actually assigning the new value to this.value), the callback should return a value. Certain
    element types (for instance input) will have attributes controlling which DOM event triggers the
    this callback (for instance 'select', 'line return', 'lose focus' etc, etc)
*/
class noiceCoreUIFormElement extends noiceCoreUIElement {

/*
    constructor({
        label:                  (str) textContent of the <label>
        labelLocation:          (enum) top | left | embed
        valueChangeCallback:    function(newValue, oldValue)
        enable:                 (bool) false = disabled, default true
        defaultValue:           (str) the default value (defaults to this.label)
        defaultValueClass:      (str) add this.formElement to this class when it contains the defaultValue (default: ncufeDefaultSelection)
        labelClass:             (str) add this this.formElementLabel (default: ncufeLabel)
    })
*/
constructor(args, defaults, callback){
    super(args, noiceObjectCore.mergeClassDefaults({
        _version:                       2.21,
        _className:                     'noiceCoreUIFormElement',
        _enable:                        true,
        _label:                         null,
        _labelLocation:                 'left',
        _name:                          null,
        _value:                         null,
        _oldValue:                      null,
        _defaultValue:                  null,
        _html:                          null,
        _hasFormElement:                false,
        _nullable:                      false,
        _undoable:                      false,
        _removable:                     false,
        _showButtons:                   false,
        _externalButtons:               [],
        removeCallback:                 null,
        removedCallback:                null,
        normalizeUpperCase:             false,
        trimWhitespace:                 false,
        xssFilterEnable:                false,
        cursorToEnd:                    false,
        _dir:                           'ltr',
        _labelClass:                    'ncufeLabel',
        _fieldClass:                    'ncuFormElementField',
        _labelLength:                   '1fr',
        _defaultValueClass:             'ncufeDefaultSelection',
        _fieldSectionClass:             'ncufeFieldSection',
        _valueLength:                   '1fr',
        _captureValueOn:                'focusoutOrReturn',
        _validationErrorClass:          'ncuFormElementValidationError',
        _validationErrorSectionClass:   'ncfueValidationErrorSection',
        _hasErrors:                     false,
        _validationErrors:              {},
        _showValidationErrors:          false,
        _visibility:                    'visible',
        _display:                       true,
        classList:                      ['ncuFormElement'],
        requiredFieldClass:             'ncufeRequiredField',
        valueChangeCallbackOverride:    false,
        _captureValueListeners:         {},
    },defaults),callback);

    /*
        note: render() got called for us by super()
        so it exists in the documentFragment
        starting here
    */

    // setup default values (meta)
    if (! this.isNotNull('label')){ this.label = this._className; }
    if (! this.isNotNull('name')){ this.name = this.label; }

    // this is the last thing that gets done before returning
    this.setup();

} // end constructor


/*
    validationErrors stuff
*/
get validationErrors(){ return(this._validationErrors); }
get hasErrors(){
    return(Object.keys(this.validationErrors).length > 0);
}
set hasErrors(v){
    if ((this.hasErrors) && (v !== true)){ this._validationErrors = {}; }
    this._hasErrors = (v === true);
}
hasError(errorNumber){ return(this._validationErrors.hasOwnProperty(errorNumber)); }
addValidationError(error){
    // note, if there was already one with this error number for this element we gon blow it away
    if (! ((error instanceof Object) && (error.hasOwnProperty('errorNumber')))){
        throw(new noiceException({
            message:        `${this._className}/addValidationError: error object does not define 'errorNumber'`,
            messageNumber:   420,
            thrownBy:       `${this._className}/addValidationError`
        }));
    }
    this.validationErrors[error.errorNumber] = error;
    this.toggleValidationErrorClass();
}
removeValidationError(errorNumber){
    delete(this._validationErrors[errorNumber]);
    this.toggleValidationErrorClass();
}
clearValidationErrors(){
    this._validationErrors = {};
    this.toggleValidationErrorClass();
}
toggleValidationErrorClass(){
    if (this.hasFormElement){
        if (this.hasErrors){
            this.DOMElement.classList.add(this._validationErrorClass);
            this.showValidationErrors = true;
        }else{
            this.DOMElement.classList.remove(this._validationErrorClass);
            this.showValidationErrors = false;
        }
    }
}
get showValidationErrors(){ return(this._showValidationErrors === true); }
set showValidationErrors(v){
    let setting = (v === true);
    if ((! this.showValidationErrors) && (setting)){

        // this is bad form with the spacer I know but ... gitrdun

        // if we don't have one yet make it
        if (! (this.validationErrorSection instanceof Element)){
            this.validationErrorSpacer = document.createElement('div')
            this.validationErrorSpacer.className = `${this._validationErrorSectionClass}_spacer`;
            this.validationErrorSection = document.createElement('div');
            this.validationErrorSection.className = this._validationErrorSectionClass;
            this.validationErrorSection.appendChild(this.validationErrorSpacer);
        }

        /* turning it on */
        Object.keys(this.validationErrors).sort().forEach(function(errorNumber){
            this.validationErrorSection.insertAdjacentHTML('beforeend',`<p>
                <span class="errorID">error#: ${errorNumber}: </span><span class="errorMessage">${this.validationErrors[errorNumber].errorMessage}</span>
            </p>`);
        }, this);
        //this.DOMElement.querySelector(`div.${this._fieldSectionClass}`).append(this.validationErrorSection);
        //this.DOMElement.append(this.validationErrorSpacer);

        // it's ms. hicox, if ya nasty ...
        if (this.labelLocation == 'left'){
            let span = document.createElement('span');
            span.innerHTML = `&nbsp;`;
            this.DOMElement.append(span);

        }
        this.DOMElement.append(this.validationErrorSection);


    }else if (this.showValidationErrors && (! setting)){
        /* turning it off */
        this.validationErrorSection.textContent = '';
        if (this.validationErrorSection instanceof Element){
            //this.validationErrorSpacer.remove();
            this.validationErrorSection.remove();
        }
    }

    this._showValidationErrors = setting;
}

/*
    getters and setters. the rest of them
*/
get dir(){ return(this._dir);}
set dir(v){
    this._dir = v;
    if (this.hasFormElement){ this.formElement.dir = this._dir; }
}
get labelLength(){ return(this._labelLength); }
set labelLength(v){
    this._labelLength = v;
    this.labelLocation = this.labelLocation;
}
get valueLength(){ return(this._valueLength); }
set valueLength(v){
    this._valueLength = v;
    this.labelLocation = this.labelLocation;
}

/* old and busted
get display(){ return(this._visibility == 'visible'); }
set display(v){ this.visibility = (v===true)?'visible':'hidden'; }
*/
// new hotness
get display(){ return(this._display); }
set display(v){
    this._display = (v == true);
    this.DOMElement.style.display = this.display?'grid':'none';
}


get edit(){ return(this._enable === true); }
set edit(v){ this.enable = (v === true); }
get enable(){ return(this._enable); }
set enable(v){
    this._enable = (v === true);
    if (this.formElement instanceof Element){ this.formElement.disabled = (! this._enable); }
}
get nullable(){ return(this._nullable); }
set nullable(b){
    this._nullable = (b === true);

    if (this.DOMElement instanceof Element){
        if (this.nullable){
            this.DOMElement.classList.remove(this.requiredFieldClass);
        }else{
            this.DOMElement.classList.add(this.requiredFieldClass);
        }
    }
}
get label(){ return(this._label); }
set label(v){

    if (this.formElement instanceof Element){
        this.formElementLabel.textContent = v;
        if ((this.labelLocation == 'embed') && (this.value == this.label)){
            this._label = v;
            this.value = v;
        }
    }
    this._label = v;
}
get labelLocation(){ return(this._labelLocation); }
set labelLocation(v){

    switch(v){
        case 'left':
            if (this.DOMElement instanceof Element){
                this.formElementLabel.style.textAlign = 'right';
                this.DOMElement.style.display = 'grid';
                this.DOMElement.style.gridTemplateColumns = `${this.labelLength} ${this.valueLength}`;
                this.formElementLabel.style.alignSelf = 'self-start';
                this.formElementLabel.style.visibility = 'visible';
                if (this.labelLocation == 'embed'){ this.embedLabel(false); }
            }
            break;
        case 'top':
            if (this.DOMElement instanceof Element){
                this.DOMElement.style.display = 'grid';
                this.DOMElement.style.gridTemplateColumns = '1fr';
                this.formElementLabel.style.textAlign = 'left';
                this.formElementLabel.style.visibility = 'visible';
                if (this.labelLocation == 'embed'){ this.embedLabel(false); }
            }
            break;
        case 'none':
            //this.formElementLabel.style.visibility = 'collapse';
            this.formElementLabel.style.display = 'none';
            if (this.labelLocation == 'embed'){ this.embedLabel(false); }
            break;
        case 'embed':
            /*
                if the child class supports label embedding (has a function called embedLabel)
                we'll pass it off to that, otherwise we're just gonna return without changing the mode
            */
            if (typeof this.embedLabel === 'function'){
                this.DOMElement.style.gridTemplateColumns = '1fr';
                this.formElementLabel.style.display = 'none';
                //this.formElementLabel.style.visibility = 'collapse';

                /*
                    very sloppy but this is so setDefaultValueStyle()
                    can know what mode we're in when it gets called from
                    the value setter, when embedLabel replaces the null value
                    (if it does)
                */
                this._labelLocation = v;
                this.embedLabel(true);
            }else{
                return(false);
            }
            break;
        default:
            return(false);
    }
    this._labelLocation = v;
}
get labelClass(){ return(this._labelClass); }
set labelClass(v){
    if (this.formElementLabel instanceof Element){
        if (this.isNotNull(this.labelClass)){
            this.formElementLabel.classList.remove(this.labelClass);
        }
        this.formElementLabel.classList.add(v);
    }
    this._labelClass = v;
}
get fieldClass(){ return(this._fieldClass); }
set fieldClass(v){
    if (this.formElement instanceof Element){
        if (this.isNotNull(this.fieldClass)){
            this.formElement.classList.remove(this.fieldClass);
        }
        this.formElement.classList.add(v);
    }
    this._fieldClass = v;
}


get name(){ return(this._name); }
set name(v){
    this._name = v;
    if (this.formElement instanceof Element){ this.formElement.setAttribute('name',this.label); }
}
get value(){
    /* NEW HOTNESS */
    let tmp = (this.formElement instanceof Element)?this.formElement.value:this._value;
    if ((this.labelLocation == 'embed') && (tmp == this.label)){
        return(null)
    }else{
        return(tmp)
    }
}


/*
    old value
*/
get oldValue(){ return(this._oldValue); }
set oldValue(v){
    this._oldValue = v;
    if ((this.undoable) && (this.btnUndo instanceof Element)){
        this.btnUndo.disabled = false;
    }
}
resetOldValue(){
    this.oldValue = null;
    if ((this.undoable) && (this.btnUndo instanceof Element)){
        this.btnUndo.disabled = true;
    }
}


/*
    value setter (as of v2 9/10/21)

    the valueChangeCallback must return a promise
    if that promise rejects, we throw and we don't set the field value
    if that promise resolves, we will set the field value to whatever is returned
    if that promise never resolves or rejects, your value will never be set
*/
set value(v){
    let that = this;
    this.setValue(v).catch((error) => {
        throw(new noiceException({
            message:        `${that._className}/value setter (callback) threw an error: ${error}`,
            messageNumber:   420,
            thrownBy:       `${that._className}/value setter (callback)`
        }));
    });
}




/*
    a better setValue(value, oldValue)
    toots false if we just toggled value for emedded label and true if we actually set a value
*/
setValue(v){
    let that = this;
    return(new Promise((toot, boot) => {

        /*
            if the label is embedded
                focus-in resets value to null if current value is label (focus-in handler does this)
                on focus-out, we should wind up here
                    if the value is null and the previous value is (null or label):
                        reset formElement.value to label and exit false
                    else
                        set the value with callback etc
                        exit
                            if value is null reset

        */

        if ((that.labelLocation == 'embed') && that.isNull(v) && (that.isNull(that._value) || (that._value == that.label))){

            // handle resetting embedded label from null
            that.formElement.value = that.label;
            that._value = that.label;
            toot(false);

        }else{

            // normalize case here if we have the flag
            if ((that.normalizeUpperCase == true) && (that.isNotNull(v))){
                v = v.toUpperCase();
            }

            // strip leading and trailing whitespace here if we have the flag
            if ((that.trimWhitespace == true) && that.isNotNull(v)){
                v = v.trim();
            }

            // xss filtering
            if ((that.xssFilterEnable == true) && that.isNotNull(vt)){
                vt = that.xssFilter(vt);
            }

            // handle the callback if we have one
            new Promise((_t,_b) => {
                if (that.valueChangeCallback instanceof Function){
                    that.valueChangeCallback(v, that._value, that).then((clbkValue) => { _t(clbkValue); }).catch((error) => { _b(error); });
                }else{
                    _t(v);
                }
            }).then((value) => {

                // handle setting the value
                that._value = value;
                if (that.formElement instanceof Element){

                    // set element value
                    that.formElement.value = ((that.labelLocation == 'embed') && that.isNull(that._value))?that.label:that._value;

                    // scroll to the end if we've got cursorToEnd set true
                    if (that.cursorToEnd && (that.formElement.value.length > 0)){
                        that.formElement.scrollLeft = that.formElement.scrollWidth;
                    }

                    // style changes as necessary
                    that.toggleDefaultValueStyle();
                }
                toot(true);

            }).catch((error) => {
                // valueChangeCallback aborted
                if ((that.debug) && (that._app instanceof noiceApplicationCore)){ that._app.log(`${that._className} v${that._version} | setValue(${v}, ${o}) | valueChangeCallback() threw unexpectedly | ${error}`); }
                boot(error);
            });

        }

    }));
}


// set the value and sneak around the valueChangeCallback
setValueDirect(v){
    this._value = v;
    if (this.hasFormElement){ this.formElement.value = v; }
}


//set the defaultValue, and the value to it, without triggering valueChangeCallback()
get defaultValue(){ return(this._defaultValue); }
set defaultValue(v){
    this._defaultValue = v;
    this._value = this.defaultValue;
    if (this.hasFormElement){ this.formElement.value = this.defaultValue; }
    this.toggleDefaultValueStyle();
}




/*
    child classes must implement html getter/setters
    such that the getters for formElement and formElementLabel
    will return correctly.

    --> that means child classes must define:

        this.formElementGUID
        this.formElementLabelGUID

    in their html setters! ya dig!
*/
get hasFormElement(){ return(this.formElement instanceof Element); }
get formElement(){
    if (this.DOMElement instanceof Element){
        return(this.DOMElement.querySelector(`#${this.formElementGUID}`));
    }else{
        return(null);
    }
}
get formElementLabel(){
    if (this.DOMElement instanceof Element){
        return(this.DOMElement.querySelector(`#${this.formElementLabelGUID}`));
    }else{
        return(null);
    }
}


/*
    setFocus()
    just give focus to the formElement element
*/
setFocus(){
    if (this.formElement instanceof Element){
        this.formElement.focus();
    }
}


/*
    toggleDefaultValueStyle();
*/
toggleDefaultValueStyle(){
    if (this.formElement instanceof Element){
        if ((this.defaultValue == this.value) || ((this.labelLocation == 'embed') && (this.value == this.label))){
            this.formElement.classList.add(this._defaultValueClass);
        }else{
            this.formElement.classList.remove(this._defaultValueClass);
        }
    }
} // end toggleDefaultValueStyle


/*
    captureValueOn
*/
get captureValueOn(){ return(this._captureValueOn); }
set captureValueOn(v){
    let that = this;
    if (that.formElement instanceof Element){

        // reset existing listeners
        Object.keys(that._captureValueListeners).forEach((eventType)=>{
            that.formElement.removeEventListener(eventType, that._captureValueListeners[eventType]);
            delete(that._captureValueListeners[eventType]);
        });

        if (v == 'return'){
            that._captureValueListeners.keydown = that.getEventListenerWrapper((evt) =>{ that.captureValue(evt); });
            that.formElement.addEventListener('keydown', that._captureValueListeners.keydown);
        }else if (v == 'focusoutOrReturn'){
            that._captureValueListeners.focusout = that.getEventListenerWrapper((evt) =>{ that.captureValue(evt); });
            that.formElement.addEventListener('focusout', that._captureValueListeners.focusout)
            that._captureValueListeners.keydown = that.getEventListenerWrapper((evt) =>{ if (evt.keyCode == 13){ that.formElement.blur(); }});
            that.formElement.addEventListener('keydown', that._captureValueListeners.keydown);
        }else{
            that._captureValueListeners[v] = that.getEventListenerWrapper((evt) =>{ that.captureValue(evt); });
            that.formElement.addEventListener(v, that._captureValueListeners.keydown)
        }
    }
    this._captureValueOn = v;
}




/*
    captureValue()
    this assigns the screen value (this.value) to
    the application value (this._value)
    invoking the valueChangeCallback
*/
captureValue(event){

    /*
        since it is apparently not really possible to remove eventListeners
        this function is gonna get called every time for every damn event
        pretty much. So all of the logic about if this thing should execute
        or not pretty much has got to live here

        might as well add the embedded label exit handler call here too
    */
    let cont = false;

    if (
        (
                ((event.type == 'keydown') && (event.keyCode == 13)) ||
                (event.type == 'focusout')
        ) && (
            (this.captureValueOn == 'focusoutOrReturn') || (this.captureValueOn == 'return'))
    ){
        cont = true;
    }else if (this.captureValueOn == event.type){
        cont = true;
    }


    if (cont){

        // this feels very punk rock to me right now. opinion subject to change.
        this.value = this.value;

    }
}



/*
    the last thing to execute on instantiation.
    this is good for setting defaults and stuff.
    if the caller needs to hang hooks n' such,
    renderCallback() is fine for that. This is
    for hard-coded-ey type stuff.
*/
setup(){
    let that = this;

    /*
        setup the undoButton and the removeButton
        see attribute setters: undoable, removable, showButtons
    */
    this.fieldSection = this.DOMElement.querySelector(`div.${this._fieldSectionClass}`);
    this.fieldBtnContainer = document.createElement('div');
    this.fieldBtnContainer.className = 'fieldBtnContainer';

    ['btnRemove', 'btnUndo'].forEach(function(btnName){
        that[btnName] = document.createElement('button');
        that[btnName].className = btnName;
        that[btnName].style.display = 'none';
        that.fieldBtnContainer.appendChild(that[btnName]);
    });

    // btnUndo inits disabled
    that.btnUndo.disabled = true;
    that.btnUndo.addEventListener('click', function(){ that.undo(); });

    // hook for btnRemove
    that.btnRemove.addEventListener('click', function(){ that.handleRemove(); });

    // hook for focusInCallback
    this.formElement.addEventListener('focusin', function(evt){
        if (that.focusInCallback instanceof Function){ that.focusInCallback(that, evt); }
    });

    /*
        explicitly set default values now that we're completely sure
        that everything has been rendered
    */
    this.enable          = this._enable;
    this.label           = this._label;
    this.labelLocation   = this._labelLocation;
    this.name            = this._name;
    this.value           = this._value;
    this.captureValueOn  = this.captureValueOn;
    this.fieldClass      = this._fieldClass;
    this.labelClass      = this._labelClass;
    this.removable       = this._removable;
    this.undoable        = this._undoable;
    this.externalButtons = this._externalButtons;

} // end setup()


/*
    showButtons accessor
*/
get showButtons(){ return(this._showButtons); }
set showButtons(v){
    this._showButtons = (v == true);
    if (this.fieldBtnContainer instanceof Element){
        if (this.showButtons){
            this.fieldSection.appendChild(this.fieldBtnContainer);
        }else{
            this.fieldBtnContainer.remove();
        }
    }
}


/*
    undoable accessor
*/
get undoable(){ return(this._undoable); }
set undoable(v){
    this._undoable = (v == true);
    if (this.btnUndo instanceof Element){ this.btnUndo.style.display = this.undoable?'block':'none'}
    this.showButtons = (this.undoable || this.removable || this.hasExternalButtons);
}
undo(){
    if (this.undoable){
        let abrt = false;
        let that = this;
        this.setValue(this.oldValue).catch(function(error){
            abrt = true;
            if (that.debug){ console.log(`${this._className} | ${this.label} | undo | cancelled by setValue(): ${error}`); }
        }).then(function(){
            if (! abrt){ that.btnUndo.disabled = true; }
        })
    }
}


/*
    removable accessor
*/
get removable(){ return(this._removable); }
set removable(v){
    this._removable = (v == true);
    if (this.btnRemove instanceof Element){ this.btnRemove.style.display = this.removable?'block':'none'}
    this.showButtons = (this.undoable || this.removable || this.hasExternalButtons);
}
handleRemove(){
    let that = this;
    let bigAbort = false;
    new Promise(function(toot, boot){
        if (that.removeCallback instanceof Function){
            let cbAbort = false;
            that.removeCallback(that).catch(function(error){
                cbAbort = true;
                boot(error);
            }).then(function(){
                if (! cbAbort){ toot(true); }
            });
        }else{
            toot(true);
        }
    }).catch(function(error){
        bigAbort = true;
        if (that.debug){ console.log(`${that._className} | ${that.label} | removeCallback cancelled field remove: ${error}`); }
    }).then(function(){
        if (! bigAbort){
            that.remove();
            // this one fires after it's actually been removed (for managing menus n' stuff)
            if (that.removedCallback instanceof Function){ that.removedCallback(that); }
        }
    });
}


/*
    externalButtons
*/
get hasExternalButtons(){ return(this._externalButtons.length > 0); }
get externalButtons(){ return(this._externalButtons); }
set externalButtons(v){
    let that = this;
    if (v instanceof Array){

        // remove any existing ones
        that._externalButtons.forEach(function(btn){
            if (btn instanceof Element){ btn.remove(); }
        });

        // add the new ones
        that.showButtons = ((v.length > 0) || this.undoable || this.removable);
        let tmp = [];
        v.forEach(function(btn){
            if (that.fieldBtnContainer instanceof Element){ that.fieldBtnContainer.appendChild(btn); }
            tmp.push(btn);
        });
        that._externalButtons = tmp
    }
}




/*
    xssFilter(string)
    returns as sanitized of a string as we know how to do.
    override this function if you want to point to an external library
    or what have you. This is called by default in the value setter
    if the xssFilterEnable attribute is set true.

    this approach is super-naive I might add, but it's better than nothing
*/
xssFilter(str){
    let div = document.createElement('div');
    div.textContent = str;
    return(div.innerHTML);
}




} // end noiceCoreUIFormElement




/*
    noiceCoreUInput
    a single line character input <input>
    NOTE this needs expansion -- this is the *text type* of input there are many more
*/
class noiceCoreUIFormElementInput extends noiceCoreUIFormElement {


/*
    constructor({
        [inherited properties from above, plus]
        captureValueOn:     focusout | return | focusoutOrReturn (default) | keypress | input
                            executes this.value = this.value (yeah really)
                            it takes the screen value (this.value) and applies
                            it to the application value (this._value), invoking
                            the valueChangeCallback. It does all of that when
                            this.formElement receives an event defined thusly:
                                focusout            -> DOM focusout event
                                return              -> on DOM keypress event checks for linereturn and fires
                                focusoutOrReturn    -> both of the above
                                keypress            -> go get it! one key at a time!
                                input               -> DOM input event
        values:           [array, of, values, for, typeahead, menu, feature],
    })
*/
constructor(args, defaults, callback){
    super(args, noiceObjectCore.mergeClassDefaults({
        _version:                           1,
        _className:                         'noiceCoreUIInput',
        _hasEmbededLabelEventListener:      false,
        _embededLabelEventListener:         null,
        _values:                            [],
        _maxLength:                         null,
        _minLength:                         null,
        _readonly:                          false,
        _size:                              null,
        _spellcheck:                        false,
        _autocorrect:                       false,
        _autocomplete:                      "off",
        _required:                          false
    }, defaults), callback);

} // end constructor

// required
get required(){ return(this._required); }
set required(v){
    this._required = (v === true);
    this.formElement.setAttribute('required', this.required);
    if (! this.required){ this.formElement.removeAttribute('required'); }
}

/*
    autocomplete
    there's a lot that you can do with this:
    https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/autocomplete#Values
*/
get autocomplete(){ return(this._autocomplete); }
set autocomplete(v){
    this._autocomplete = v;
    if (this.DOMElement instanceof Element){ this.DOMElement.autocomplete = v}
}

// autocorrect
get autocorrect(){ return(this._autocorrect); }
set autocorrect(v){
    this._autocorrect = (v === true);
    this.formElement.setAttribute('autocorrect', this.autocorrect);
}

// spellcheck
get spellcheck(){ return(this._spellcheck); }
set spellcheck(v){
    this._spellcheck = (v === true);
    this.formElement.setAttribute('spellcheck', this.spellcheck);
}

// size
get size(){ return(this._size); }
set size(v){
    if (this.isNull(v)){
        this.formElement.removeAttribute('size');
    }else{
        this.formElement.setAttribute('size', v);
    }
    this._size = v;
}

// readonly
get readonly(){ return(this._readonly); }
set readonly(v){
    this._readonly = (v === true);
    this.formElement.setAttribute('readonly', this.readonly);
    if (! this.readonly){ this.formElement.removeAttribute('readonly'); }
}

/* maxLength, minLength */
get maxLength(){ return(this._maxLength); }
set maxLength(v){
    if (this.isNull(v) || (v == 0)){
        this.formElement.removeAttribute('maxLength');
    }else{
        this.formElement.setAttribute('maxLength', v);
    }
    this._maxLength = v;
}
get minLength(){ return(this._minLength); }
set minLength(v){
    if (this.isNull(v)){
        this.formElement.removeAttribute('minLength');
    }else{
        this.formElement.setAttribute('minLength', v);
    }
    this._minLength = v;
}

/*
    values getter and setter
*/
get values(){ return(this._values); }
set values(v){
    this._values = v;
    if (this.hasOwnProperty('DOMElement')){ this.updateOptions(); }
}

/*
    options in this context is an array on this.values
    of typeahead menu options
*/
updateOptions(){
    let that = this;

    // if we're not setup yet don't bother ...
    if (! that.hasAttribute('formElementDataList')){ return(false); }

    /*
        handling existing values
        if the field has an existing value, and
        it exists in the new list of values
        then we will restore the selection
        without toggling the change flag.
    */
    let existingValue = that.value;
    let foundExisting = false;

    // remove everything
    that.formElement.removeAttribute('list');
    while(that.formElementDataList.firstChild){ that.formElementDataList.removeChild(that.formElementDataList.firstChild); }

    // replace options
    that.values.forEach(function(v){
        let t = document.createElement('option');
        t.value = v;
        if (that.isNotNull(existingValue) && (t.value == existingValue)){
            foundExisting = true;
            t.setAttribute('selected', 'true');
        }
        that.formElementDataList.append(t);
    });

    // attach datalist to formElement if we have some values
    if (that.values.length > 0){ that.formElement.setAttribute('list', that.formElementDataListGUID); }
}


/*
    setup()
*/
setup(){
    super.setup();
    this.formElementDataList = this.DOMElement.querySelector(`#${this.formElementDataListGUID}`);
    if (this.values.length > 0){ this.updateOptions(); }

    // initialize options with default values that need to be setup post-render
    ['minLength', 'maxLength', 'readonly', 'size', 'spellcheck', 'autocorrect', 'autocomplete', 'required', 'labelLocation'].forEach(function(att){
        this[att] = this[att];      // bitchin'
    }, this);
}



/*
    html getter
*/
get html(){
    if (! this.hasAttribute('formElementGUID')){ this.formElementGUID = this.getGUID(); }
    if (! this.hasAttribute('formElementLabelGUID')){ this.formElementLabelGUID = this.getGUID(); }
    if (! this.hasAttribute('formElementDataListGUID')){ this.formElementDataListGUID = this.getGUID(); }

    return(`
        <label id="${this.formElementLabelGUID}" for="${this.formElementGUID}" class="${this.labelClass}">${this.label}</label><div class="${this._fieldSectionClass}">
        <input id="${this.formElementGUID}" name="${this.name}" ${(this.enable)?'enabled':'disabled'} type="text"></input>
        <datalist id="${this.formElementDataListGUID}"></datalist></div>
    `);
}




/*
    embedLabel(bool)
    handle embedding and disembedding the label (that's a word, right?)
    version 2
*/
embedLabel(bool){
    let that = this;
    if (bool === true){

        // embed
        if (that.isNull(that._embededLabelEventFocusListener)){
            that._embededLabelEventListener = that.getEventListenerWrapper((evt) =>{
                if (
                    (that.formElement instanceof Element) &&
                    (that.labelLocation == 'embed') &&
                    (that.formElement.value == that.label)
                ){
                    that.formElement.value = null;
                    that._value = null;
                }
            });
        }
        this.formElement.addEventListener('focusin', that._embededLabelEventListener, true);

        // init the embedded label
        if ((that.formElement instanceof Element) && that.isNull(that.formElement.value)){
            that.formElement.value = that.label;
        }

    }else{
        // disembed
        if (that.isNotNull(that._embededLabelEventFocusListener)){
            if (that.formElement instanceof Element){ that.formElement.removeEventListener('focusin', that._embededLabelEventFocusListener, true); }
            that._embededLabelEventFocusListener = null;
        }

        // un-init the embedded label
        if ((that.formElement instanceof Element) && (that.formElement.value == that.label)){ that.formElement.label = null; }
    }
}




} // end noiceCoreUIFormElementInput




/*
    noiceCoreUIFormElementDateTime
    this is a char field where we do epoch conversion on set/get
    allowed input formats are ISO 8601. If we want others we're
    gonna have to write a proper date parser or use a lib.

    this works out, because all the dateTime fields in NSCAN
    are readonly.
*/
class noiceCoreUIFormElementDateTime extends noiceCoreUIFormElementInput {


/*
    constructor
*/
constructor(args, defaults, callback){
    super(args, noiceObjectCore.mergeClassDefaults({
        _version:                           1,
        _className:                         'noiceCoreUIFormElementDateTime',
        _dateValue:                         null
    }, defaults), callback);
} // end constructor


/*
    override value getter and setter to translate epoch
*/
get value(){
    if (this.isNotNull(this._dateValue)){
        return(this._dateValue);
    }else{
        return(super.value);
    }
}

set value(v){
    /*
        NOTE: we accept ISO 8601 or epoch as input only
        if you need more date formats, override this.toEpoch

    */
    if (/^\d{10,13}$/.test(v)){
        this._dateValue = v;
    }else{
        this._dateValue = this.isNull(v)?null:this.toEpoch(v, true);
    }
    super.value = this.isNull(v)?null:this.fromEpoch(this._dateValue, 'dateTimeLocale');
}


} // end noiceCoreUIFormElementDateTime




/*
    noiceCoreUIFormElementPassword
    just like char (above) but masked
*/
class noiceCoreUIFormElementPassword extends noiceCoreUIFormElementInput {


/*
    constructor
*/
constructor(args, defaults, callback){
    super(args, noiceObjectCore.mergeClassDefaults({
        _version:                           1,
        _className:                         'noiceCoreUIFormElementPassword',
    }, defaults), callback);
} // end constructor


/*
    html getter
*/
get html(){
    if (! this.hasAttribute('formElementGUID')){ this.formElementGUID = this.getGUID(); }
    if (! this.hasAttribute('formElementLabelGUID')){ this.formElementLabelGUID = this.getGUID(); }
    if (! this.hasAttribute('formElementDataListGUID')){ this.formElementDataListGUID = this.getGUID(); }

    return(`
        <label id="${this.formElementLabelGUID}" for="${this.formElementGUID}" class="${this.labelClass}">${this.label}</label><div class="${this._fieldSectionClass}">
        <input id="${this.formElementGUID}" name="${this.name}" ${(this.enable)?'enabled':'disabled'} type="password"></input>
        <datalist id="${this.formElementDataListGUID}"></datalist></div>
    `);
}

} // end noiceCoreUIFormElementPassword




/*
    noiceCoreUISelect    (noiceCoreUIFormElementSelect)
    it's a dropdown menu
*/
class noiceCoreUIFormElementSelect extends noiceCoreUIFormElement {

/*
    constructor({-
        values:         <obj> || <array>,
                        list of values for the menu.
                        the list can be flat strings or objects of the format value:displayValue

        defaultValue    <value in this.values>
                        make it born with this value (unless the label is embedded)

        includeNull     <bool>
                        if true, there is no default selection for the field
    })
*/
constructor(args, defaults, callback){
    super(args, noiceObjectCore.mergeClassDefaults({
        _version:                           1.2,
        _className:                         'noiceCoreUISelect',
        _values:                            [],
        _selectedOption:                    null,
        _selectedOptionGroup:               null,
        captureValueOn:                     'input',
        includeNull:                        true,
        labelValueList:                     [],
        valueList:                          [],
        embeddedLabelClass:                 'noiceCoreUIFormElementSelectEmbeddedLabelClass'
    }, defaults), callback);
} // end constructor


/*
    get selectedOption and selectedOptionGroup
*/
get selectedOption(){
    return ((this.formElement instanceof Element)?this.formElement.selectedIndex:this._selectedOption);
}
set selectedOption(idx){
    this._selectedOption = parseInt(idx);
    if (this.formElement instanceof Element){ this.formElement.selectedIndex(this._selectedOption); }
}
get selectedOptionElement(){
    return ((this.formElement instanceof Element)?this.formElement.options[this.selectedOption]:null);
}
get selectedOptionLabel(){
    return ((this.formElement instanceof Element)?this.selectedOptionElement.label:null);
}
get selectedOptionGroup(){
    return ((this.formElement instanceof Element)?this.formElement.options[this.selectedOption].parentNode.label:null);
}

/*
    values getter and setter
*/
get values(){ return(this._values); }
set values(v){
    this._values = v;
    if (this.hasOwnProperty('DOMElement')){ this.updateOptions(); }
}

/*
    override value setter to handle enums
*/
set value(v){

    // handle enum decode
    let useValue = v;
    if ((! (this.values.indexOf(v) >=0)) && (! isNaN(parseInt(v)))){ useValue = this.values[v]; }

    super.value = useValue;

    // hack for embedded label
    if ((this._embeddedLabelOptionElement instanceof Element) && (this.isNull(useValue))){
        this.formElement.selectedIndex = 0;
    }
}
get value(){
    return(super.value);
}

/*
    kill all of the options, then blow 'em back in from this.values'
*/
updateOptions(){


        let that = this;

        if (!(this.formElement instanceof Element)){  return(false); }
        let existingValue = this.value;

        // clear out the old ones
        let tmp = this.formElement.options.length;                       // <-- <select>.options is a live list -- lesson learned
        for (let i=0; i < tmp; i++ ){ this.formElement.remove(0); }
        this.formElement.querySelectorAll('optgroup').forEach(function(e){
            that.formElement.removeChild(e);
        });

        // helper function returns a DOM Element corresponding to an array entry on this.values
        function getDOMElements(data){
            let el;
            if (typeof(data) == 'object'){
                if (data instanceof Array){

                    // [value, text]{
                    el = document.createElement('option');
                    el.value = data[0];
                    if (that.isNotNull(data[1])){ el.text = data[1]; }
                    el.selected = (that.isNotNull(that.value) && (that.value == el.value || that.value == el.text));

                }else if (data instanceof Object){
                    if (data.hasOwnProperty('label') && that.isNotNull(data.label) && data.hasOwnProperty('values') && (data.values instanceof Array)){

                        // { label: <submenuTitle>, data = [str,array,obj]}
                        // <optgroup>
                        el = document.createElement('optgroup');
                        el.label = data.label;
                        data.values.forEach(function(r){
                            let t =  getDOMElements(r);
                            el.append(t);
                        });
                    }else{
                        // { <value>:<displayValue>}
                        el = document.createElement('option');
                        el.value    = Object.keys(data)[0];
                        el.text     = data[el.value];
                        el.selected = (that.isNotNull(that.value) && (that.value == el.value || that.value == el.text));
                    }
                }
            }else if (typeof(data) == 'string'){
                // value == text == data
                el = document.createElement('option');
                el.value = data;
                el.text = data;
                el.selected = (that.isNotNull(that.value) && (that.value == el.value || that.value == el.text));
            }
            el.disabled = false;
            return(el);
        }

        if (this.includeNull){
            let nullChoice = document.createElement('option');
            nullChoice.selected = true;
            nullChoice.defaultSelected = true;
            nullChoice.value = null;
            nullChoice.text = "";
            this.formElement.add(nullChoice);
        }

        // handle the special embedded label if we got it
        if (this._embeddedLabelOptionElement instanceof Element){
            this.formElement.add(this._embeddedLabelOptionElement);
        }

        this.values.forEach(function(o){
            this.formElement.add(getDOMElements(o));
        }, this);

        // if changing the value list changed the element's value trigger the value change callback
        if (this.value !== existingValue){
            //this.value = this.value;  // no-no
            if (this.hasAttribute('valueChangeCallback') && (this.valueChangeCallback instanceof Function)){
                try {
                    let tmp = this.valueChangeCallback(this.value, existingValue, this);
                }catch(e){
                    throw(new noiceException({
                        message:        `${this._className}/value updateOptions changed select value (callback) threw an error: ${e.toString()}`,
                        messageNumber:   420,
                        thrownBy:       `${this._className}/value updateOptions (value setter callback)`
                    }));
                }
            }
        }

        return(true);
}

embedLabel(bool){

    /*
        note: embeded label mode really doesn't work that
        well with option groups
    */

    let that = this;
    if (bool === true){
        /*
            add the non-selectable label at index 0
        */
        if (! this.hasAttribute('_embeddedLabelOptionElement')){
            this._embeddedLabelOptionElement = document.createElement('option');
        }
        this._embeddedLabelOptionElement.disabled         = (! (this.hasOwnProperty('selectableLabel') && (this.selectableLabel == true)));
        this._embeddedLabelOptionElement.value            = this.label;
        this._embeddedLabelOptionElement.text             = this.label;
        this._embeddedLabelOptionElement.selected         = true;
        this._embeddedLabelOptionElement.defaultSelected  = true;
        this._embeddedLabelOptionElement.classList.add(this.embeddedLabelClass);
        this.formElement.add(this._embeddedLabelOptionElement, 0);
        this.toggleDefaultValueStyle();

    }else{
        /*
            remove it
        */
        if (this.hasAttribute('_embeddedLabelOptionElement')){
            this.formElement.remove(0);
            delete(this._embeddedLabelOptionElement);
        }
    }
}


/*
    html getter
*/
get html(){
    if (! this.hasAttribute('formElementGUID')){ this.formElementGUID = this.getGUID(); }
    if (! this.hasAttribute('formElementLabelGUID')){ this.formElementLabelGUID = this.getGUID(); }

    return(`
        <label id="${this.formElementLabelGUID}" for="${this.formElementGUID}" class="${this.labelClass}">${this.label}</label><div class="${this._fieldSectionClass}">
        <select id="${this.formElementGUID}" name="${this.name}" ${(this.enable)?'enabled':'disabled'}></select></div>
    `);
}

/*
    setup()
*/
setup(){
    super.setup();

    // setup the options
    this.updateOptions();

    // fire the initial selection
    this.value = this._value;

    // and show the embedded label if that's what we're doing
    if ((this._embeddedLabelOptionElement instanceof Element) && (this.isNull(this.value))){
        this.formElement.selectedIndex = 0;
    }
}


} // end noiceCoreUISelect




/*
    noiceCoreUIFormElementText

    * textarea (multi-line text entry)
      https://developer.mozilla.org/en-US/docs/Web/HTML/Element/textarea

*/
class noiceCoreUIFormElementText extends noiceCoreUIFormElementInput {


/*
    constructor({
        autocapitalize:     none|sentences|words|characters
        cols:               <int>   (default 20)
        rows:               <int>
        wrap:               hard|soft|off (default soft)
    })
*/
constructor(args, defaults, callback){
    super(args, noiceObjectCore.mergeClassDefaults({
        _version:                           1,
        _className:                         'noiceCoreUIText',
        _autocapitalize:                    null,
        _cols:                              20,
        _rows:                              1,
        _wrap:                              'soft',
        _resize:                            'none',
        captureValueOn:                     'focusout'
    }, defaults), callback);
} // end constructor

get resize(){ return(this._resize); }
set resize(v){
    this._resize = v;
    if (this.formElement instanceof Element){
        this.formElement.style.resize = this.resize;
    }
}

get cols(){ return(this._cols); }
set cols(v){
    this._cols = v;
    if (this.formElement instanceof Element){ this.formElement.setAttribute('cols', this.cols); }
}

get rows(){ return(this._rows); }
set rows(v){
    this._rows = v;
    if (this.formElement instanceof Element){ this.formElement.setAttribute('rows', this.rows); }
}

get autocapitalize(){ return(this._autocapitalize); }
set autocapitalize(v){
    this._autocapitalize = v;
    if (this.formElement instanceof Element){
        if (this.isNull(v)){
            this.formElement.removeAttribute('autocapitalize');
        }else{
            this.formElement.setAttribute('autocapitalize', this.autocapitalize);
        }
    }
}

get wrap(){ return(this._wrap); }
set wrap(v){
    this._wrap = v;
    if (this.formElement instanceof Element){
        if (this.isNull(v)){
            this.formElement.removeAttribute('wrap');
        }else{
            this.formElement.setAttribute('wrap', this.wrap);
        }
    }
}


/*
    setup()
*/
setup(){
    super.setup();

    // initialize options with default values that need to be setup post-render
    ['cols', 'rows', 'autocapitalize', 'wrap', 'resize'].forEach(function(att){
        this[att] = this[att];      // bitchin'
    }, this);
}


/*
    html getter
*/
get html(){
    if (! this.hasAttribute('formElementGUID')){ this.formElementGUID = this.getGUID(); }
    if (! this.hasAttribute('formElementLabelGUID')){ this.formElementLabelGUID = this.getGUID(); }
    if (! this.hasAttribute('formElementDataListGUID')){ this.formElementDataListGUID = this.getGUID(); }

    return(`
        <label id="${this.formElementLabelGUID}" for="${this.formElementGUID}" class="${this.labelClass}">${this.label}</label><div class="${this._fieldSectionClass}">
        <textarea id="${this.formElementGUID}" name="${this.name}" ${(this.enable)?'enabled':'disabled'}></textarea>
        <datalist id="${this.formElementDataListGUID}"></datalist></div>
    `);
}

} // end noiceCoreUIFormElementText




/*
    noiceCoreUIFormElementNumber

    * number (it's a remedy style integer with the arrows and everything!)
    https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/number
*/
class noiceCoreUIFormElementNumber extends noiceCoreUIFormElementInput {


/*
    constructor({
        min:        <number>
        max:        <number>
        step:       <number> (increment) default: 'any'
                             note this can be used to control precision for floating point numbers
                             for instance set step=.001 to imply a precision of 3
    })

    NOTE: it looks like hiding/showing the number input spinner is a whole pain in the ass currently
          https://developer.mozilla.org/en-US/docs/Web/CSS/::-webkit-inner-spin-button
*/
constructor(args, defaults, callback){
    super(args, noiceObjectCore.mergeClassDefaults({
        _version:                           1,
        _className:                         'noiceCoreUIText',
        _min:                               0,
        _max:                               1,
        _step:                              .01,
        captureValueOn:                     'focusoutOrReturn'
    }, defaults), callback);
} // end constructor

/*
    html getter
*/
get html(){
    if (! this.hasAttribute('formElementGUID')){ this.formElementGUID = this.getGUID(); }
    if (! this.hasAttribute('formElementLabelGUID')){ this.formElementLabelGUID = this.getGUID(); }
    if (! this.hasAttribute('formElementDataListGUID')){ this.formElementDataListGUID = this.getGUID(); }

    return(`
        <label id="${this.formElementLabelGUID}" for="${this.formElementGUID}" class="${this.labelClass}">${this.label}</label><div class="${this._fieldSectionClass}">
        <input type="number" id="${this.formElementGUID}" name="${this.name}" ${(this.enable)?'enabled':'disabled'}></input>
        <datalist id="${this.formElementDataListGUID}"></datalist></div>
    `);
}

/*
    getters n' setters
*/
get min(){ return(this._min); }
set min(v){
    this._min = v;
    if (this.formElement instanceof Element){
        if (this.isNull(v)){
            this.formElement.removeAttribute('min');
        }else{
            this.formElement.setAttribute('min', v);
        }
    }
}

get max(){ return(this._max); }
set max(v){
    this._max = v;
    if (this.formElement instanceof Element){
        if (this.isNull(v)){
            this.formElement.removeAttribute('max');
        }else{
            this.formElement.setAttribute('max', v);
        }
    }
}

get step(){ return(this._step); }
set step(v){
    this._step = v;
    if (this.formElement instanceof Element){
        if (this.isNull(v)){
            this.formElement.removeAttribute('step');
        }else{
            this.formElement.setAttribute('step', v);
        }
    }
}

/*
    setup()
*/
setup(){
    super.setup();

    // initialize options with default values that need to be setup post-render
    ['min', 'max', 'step'].forEach(function(att){ this[att] = this[att]; }, this);
}


} // end noiceCoreUIFormElementNumber





/*
    noiceCoreUIFormElementDate

    * date (date picker)
      https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/date
*/
class noiceCoreUIFormElementDate extends noiceCoreUIFormElementNumber {


/*
    constructor({
        min:        <number>
        max:        <number>
        step:       <number> (increment) default: 'any'
                             note this can be used to control precision for floating point numbers
                             for instance set step=.001 to imply a precision of 3
    })

    NOTE: it looks like hiding/showing the number input spinner is a whole pain in the ass currently
          https://developer.mozilla.org/en-US/docs/Web/CSS/::-webkit-inner-spin-button
*/
constructor(args, defaults, callback){
    super(args, noiceObjectCore.mergeClassDefaults({
        _version:                           1,
        _className:                         'noiceCoreUIFormElementDate',
        _min:                               '1970-01-01',
        _max:                               '2270-01-01',
        _step:                              1,
        captureValueOn:                     'focusoutOrReturn'
    }, defaults), callback);
} // end constructor

/*
    html getter
*/
get html(){
    if (! this.hasAttribute('formElementGUID')){ this.formElementGUID = this.getGUID(); }
    if (! this.hasAttribute('formElementLabelGUID')){ this.formElementLabelGUID = this.getGUID(); }
    if (! this.hasAttribute('formElementDataListGUID')){ this.formElementDataListGUID = this.getGUID(); }

    return(`
        <label id="${this.formElementLabelGUID}" for="${this.formElementGUID}" class="${this.labelClass}">${this.label}</label><div class="${this._fieldSectionClass}">
        <input type="date" id="${this.formElementGUID}" name="${this.name}" ${(this.enable)?'enabled':'disabled'}></input>
        <datalist id="${this.formElementDataListGUID}"></datalist></div>
    `);
}


}  // noiceCoreUIFormElementDate



/*
    noiceCoreUIFormElementCheckbox

    * checkbox
      https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/checkbox
*/
class noiceCoreUIFormElementCheckbox extends noiceCoreUIFormElement {

/*
    constructor({
        * checked   <bool>
    })
*/
constructor(args, defaults, callback){
    super(args, noiceObjectCore.mergeClassDefaults({
        _version:                           1,
        _className:                         'noiceCoreUICheckbox',
        _required:                          false,
        _checked:                           false,
        _readonly:                          false,
        captureValueOn:                     'input',
    }, defaults), callback);
} // end constructor

/*
    getters and setters
*/
get required(){ return(this._required); }
set required(v){
    this._required = (v === true);
    if (this.formElement instanceof Element){
        if (this._required){
            this.formElement.setAttribute('required', true);
        }else{
            this.formElement.removeAttribute('required');
        }
    }
}
get checked(){ return(this._checked); }
set checked(v){
    this._checked = (v === true);
    if (this.formElement instanceof Element){
        if (this._checked){
            this.formElement.setAttribute('checked', true);
        }else{
            this.formElement.removeAttribute('checked');
        }
    }
}
get readonly(){ return(this._readonly); }
set readonly(v){
    this._readonly = (v === true);
    if (this.formElement instanceof Element){
        if (this._readonly){
            this.formElement.setAttribute('readonly', true);
        }else{
            this.formElement.removeAttribute('readonly');
        }
    }
}

/*
    value getter/setter override
*/
get value(){
    return((this.formElement instanceof Element)?(this.formElement.checked):this._value);
}
set value(v){
    this.setValue(v == true).catch(function(error){
        throw(new noiceException({
            message:        `${that._className}/value setter (callback) threw an error: ${error}`,
            messageNumber:   420,
            thrownBy:       `${that._className}/value setter (callback)`
        }));
    });
}
// this is set value but we return the promise so you can catch it on your own
setValue(v){
    let that = this;

    // handle the callback if we have one
    return new Promise(function(t, b){

        let setValueAbort = false;
        new Promise(function(toot, boot){

            if (
                (that.valueChangeCallback instanceof Function) &&
                (! ((that.labelLocation == 'embed') && (v == that.label)))
            ){
                let callbackAbort = false;
                that.valueChangeCallback(v, that._value, that).catch(function(error){
                    callbackAbort = true;
                    boot(error);
                }).then(function(clbkValue){
                    if (! callbackAbort){
                        toot(clbkValue);
                    }
                })
            }else{
                toot(v);
            }

        }).catch(function(error){

            setValueAbort = true;
            b(error);

        }).then(function(value){

            if (! setValueAbort){
                // handle setting the value
                if (that.undoable){ that.oldValue = that._value; }
                that._value = value;
                if (that.formElement instanceof Element){ that.formElement.checked = that._value; }
                that.toggleDefaultValueStyle();
                t(true);
            }
        });
    });
}



/*
    html getter
*/
get html(){
    if (! this.hasAttribute('formElementGUID')){ this.formElementGUID = this.getGUID(); }
    if (! this.hasAttribute('formElementLabelGUID')){ this.formElementLabelGUID = this.getGUID(); }

    return(`
        <label id="${this.formElementLabelGUID}" for="${this.formElementGUID}" class="${this.labelClass}">${this.label}</label><div class="${this._fieldSectionClass}">
        <input
            type="checkbox"
            id="${this.formElementGUID}"
            name="${this.name}"
            value="true"
            ${(this.enable)?'enabled':'disabled'}></input></div>
    `);
}

/*
    setup
*/
setup(){
    super.setup();
    // initialize options with default values that need to be setup post-render
    ['required', 'checked', 'readonly', 'value'].forEach(function(att){ this[att] = this[att]; }, this);
}

} // end noiceCoreUIFormElementCheckbox




/*
    noiceCoreUIFormElementFile

        * file
          https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/file
          https://developer.mozilla.org/en-US/docs/Web/API/File/Using_files_from_web_applications

      this is a file upload input
      I think this also has capability to capture an image as a file from built in cameras
      attributes:

            * value
              the pathname to the file selected (this may be extremely bogus)

            * files [FileList -- array like struct]
              list of File objects, this is how you get access to them
              https://developer.mozilla.org/en-US/docs/Web/API/File
*/
class noiceCoreUIFormElementFile extends noiceCoreUIFormElement {



/*
    constructor({
        accept:     <extensions or mime types> (default null)
        multiple:   <bool> accept multiple files or not
    })
*/
constructor(args, defaults, callback){
    super(args, noiceObjectCore.mergeClassDefaults({
        _version:           1,
        _className:         'noiceCoreUIFile',
        _accept:            null,
        _multiple:          false,
        _captureValueOn:    'change',
        _fileList:          []
    }, defaults), callback);

} // end constructor

// getters & setters
get accept(){ return(this._accept); }
set accept(v){
    this._accept = v;
    if (this.hasFormElement){
        this.formElement.setAttribute('accept', this.accept);
        if (this.isNull(v)){ this.formElement.deleteAttribute('accept'); }
    }
}
get multiple(){ return(this._multiple); }
set multiple(v){
    this._multiple = (v === true);
    if (this.hasFormElement){
        if (this._multiple){
            this.formElement.setAttribute('multiple', this.multiple);
        }else{
            this.formElement.deleteAttribute('multiple');
        }
    }
}

/*
    override value getter
    we're returning the fileList
*/

set value(v){
    let vt = v;
    if (this.hasAttribute('valueChangeCallback') && (this.valueChangeCallback instanceof Function)){
        let that = this;
        try {
            let tmp = this.valueChangeCallback(vt, this._value, that);
            if (this.isNotNull(tmp)){ vt = tmp; }
        }catch(e){
            throw(new noiceException({
                message:        `${this._className}/value setter (callback) threw an error: ${e.toString()}`,
                messageNumber:   420,
                thrownBy:       `${this._className}/value setter (callback)`
            }));
        }
    }
    this._value = vt;
}


/*
    captureValue(evt) override
    this should fire on 'change' (someone added or removed a file)
*/
captureValue(evt){

    // grab the fileList invoke the valueChangeCallback
    this.value = evt.target.files;
}


/*
    html getter
*/
get html(){
    if (! this.hasAttribute('formElementGUID')){ this.formElementGUID = this.getGUID(); }
    if (! this.hasAttribute('formElementLabelGUID')){ this.formElementLabelGUID = this.getGUID(); }

    return(`
        <label id="${this.formElementLabelGUID}" for="${this.formElementGUID}" class="${this.labelClass}">${this.label}</label><div class="${this._fieldSectionClass}">
        <input id="${this.formElementGUID}" name="${this.name}" ${(this.enable)?'enabled':'disabled'} type="file"></input></div>
    `);
}


} // end noiceCoreUIFormElementFile

export {
    noiceCoreUIFormElement,
    noiceCoreUIFormElementInput,
    noiceCoreUIFormElementDateTime,
    noiceCoreUIFormElementPassword,
    noiceCoreUIFormElementSelect,
    noiceCoreUIFormElementText,
    noiceCoreUIFormElementNumber,
    noiceCoreUIFormElementDate,
    noiceCoreUIFormElementCheckbox,
    noiceCoreUIFormElementFile
 };
